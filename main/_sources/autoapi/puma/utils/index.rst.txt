:py:mod:`puma.utils`
====================

.. py:module:: puma.utils

.. autoapi-nested-parse::

   Module for usefule tools in puma.



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   discriminant/index.rst
   generate/index.rst
   histogram/index.rst
   logging/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   puma.utils.calc_disc
   puma.utils.calc_disc_b
   puma.utils.calc_disc_c
   puma.utils.get_dummy_2_taggers
   puma.utils.get_dummy_multiclass_scores
   puma.utils.set_log_level
   puma.utils.set_xaxis_ticklabels_invisible
   puma.utils.get_good_pie_colours
   puma.utils.get_good_colours
   puma.utils.get_good_linestyles



Attributes
~~~~~~~~~~

.. autoapisummary::

   puma.utils.logger
   puma.utils.global_config


.. py:function:: calc_disc(scores: numpy.ndarray, flvs: list = None, flv_map: dict = None, epsilon: float = 1e-10) -> numpy.ndarray

   Calculate arbitrary flavour tagging score.

   :param scores: tagger scores in the shape (n_jets, n_flavours)
   :type scores: np.ndarray
   :param flvs: List of flavours corresponding to the order in the scores array, by default None
   :type flvs: list, optional
   :param flv_map: flavour map containing signal and background mapping from `flv` and their
                   fractions, by default None
   :type flv_map: dict, optional
   :param epsilon: adds a small epsilon to the numerator and denominator to avoid infinities,
                   by default 1e-10
   :type epsilon: float, optional

   :returns: discriminant values
   :rtype: np.ndarray

   :raises ValueError: if scores and shapes have different shapes

   .. rubric:: Examples

   The `flv_map` can e.g. look like this together with the `flvs`
   >>> flv_map ={
   ...     "sig": {"b": 1.0},
   ...     "bkg": {"l": 1 - 0.5, "c": 0.5},
   ... }
   >>> flvs = ["l", "c", "b"]
   >>> scores = np.column_stack((np.ones(10), np.ones(10), np.ones(10)))
   >>> calc_disc(scores, flvs=flvs, flv_map=flv_map)
   array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])


.. py:function:: calc_disc_b(arr_pu: numpy.ndarray, arr_pc: numpy.ndarray, arr_pb: numpy.ndarray, fc_par: float, epsilon: float = 1e-10) -> numpy.ndarray

   Calculate b-tagging discriminant with one fc parameter.

   :param arr_pu: Light prediction scores
   :type arr_pu: np.ndarray
   :param arr_pc: c prediction scores
   :type arr_pc: np.ndarray
   :param arr_pb: b prediction scores
   :type arr_pb: np.ndarray
   :param fc_par: fc parameter for b-jet discriminant
   :type fc_par: float
   :param epsilon: adds a small epsilon to the numerator and denominator to avoid infinities,
                   by default 1e-10
   :type epsilon: float, optional

   :returns: b-tagging discriminant
   :rtype: np.ndarray

   :raises ValueError: if inputs has not the same length


.. py:function:: calc_disc_c(arr_pu: numpy.ndarray, arr_pc: numpy.ndarray, arr_pb: numpy.ndarray, fb_par: float, epsilon: float = 1e-10) -> numpy.ndarray

   Calculate c-tagging discriminant with one fb parameter.

   :param arr_pu: Light prediction scores
   :type arr_pu: np.ndarray
   :param arr_pc: c prediction scores
   :type arr_pc: np.ndarray
   :param arr_pb: b prediction scores
   :type arr_pb: np.ndarray
   :param fb_par: fb parameter for c-jet discriminant
   :type fb_par: float
   :param epsilon: adds a small epsilon to the numerator and denominator to avoid infinities,
                   by default 1e-10
   :type epsilon: float, optional

   :returns: b-tagging discriminant
   :rtype: np.ndarray

   :raises ValueError: if inputs has not the same length


.. py:function:: get_dummy_2_taggers(size: int = 9999, shuffle: bool = True, seed: int = 42, add_pt: bool = False)

   Wrapper function of `get_dummy_multiclass_scores` to generate classifier output
   for 2 taggers, in this case rnnip and dips as well as HadronConeExclTruthLabelID.


   :param size: Size of dummy data, by default 9_999
   :type size: int, optional
   :param shuffle: If True shuffles the dummy data, by default True
   :type shuffle: bool, optional
   :param seed: Random seed for number generation (will count +10 for second tagger),
                by default 42
   :type seed: int, optional
   :param add_pt: Specify if pt column should be added as well, by default False
   :type add_pt: bool, optional

   :returns: **df_gen** -- Dataframe with columns
             [HadronConeExclTruthLabelID, rnnip_pu, rnnip_pc, rnnip_pb, dips_pu, dips_pc,
             dips_pb] if `add_pt` is True also pt is added
   :rtype: pandas.DataFrame


.. py:function:: get_dummy_multiclass_scores(size: int = 9999, bjets_mean: float = 1.4, seed: int = 42)

   Generate dummy data representing output of 3 class classifier.
   Adapted to light-, c- and b-jets and values of `HadronConeExclTruthLabelID`.

   :param size: Size of dummy data. For each of the 3 classes, the same amount is produced,
                if size cannot be divided by 3, next smaller number is taken,
                by default 9_999
   :type size: int, optional
   :param bjets_mean: Mean value of the b-jets 3D gaussian, the more away from 0, the better the
                      b-tagging performance, by default 1.4
   :type bjets_mean: float, optional
   :param seed: Random seed for number generation, by default 42
   :type seed: int, optional

   :returns: * *np.ndarray* -- Output scores of the shape (size, 3)
             * *np.ndarray* -- Labels of shape (size,). The order of the output is light-jets, c-jets, b-jets


.. py:data:: logger
   

   

.. py:function:: set_log_level(puma_logger, log_level: str)

   Setting log level.

   :param puma_logger: logger object
   :type puma_logger: logger
   :param log_level: Logging level corresponding CRITICAL, ERROR, WARNING, INFO, DEBUG, NOTSET
   :type log_level: str


.. py:function:: set_xaxis_ticklabels_invisible(ax)

   Helper function to set the ticklabels of the xaxis invisible

   :param ax: Axis you want to modify
   :type ax: matplotlib.axes.Axes


.. py:function:: get_good_pie_colours(colour_scheme=None)

   Helper function to get good colours for a pie chart. You can
   choose between a specific colour scheme or use the default colours
   for a pie chart

   :param colour_scheme: colour scheme for the pie chart. Can be None to use default colours
                         or blue, red, green or yellow to use a specific colour scheme
   :type colour_scheme: string, optional

   :returns: returns a list of colours in the specified colour scheme
   :rtype: list

   :raises KeyError: If colour_scheme is not in ["blue", "red", "green", "yellow", None]


.. py:function:: get_good_colours(colour_scheme=None)

   List of colours adequate for plotting

   :param colour_scheme: colour scheme for line plots, by default None
   :type colour_scheme: string, optional

   :returns: list with colours
   :rtype: list


.. py:function:: get_good_linestyles(names=None)

   Returns a list of good linestyles

   :param names: List or string of the name(s) of the linestyle(s) you want to retrieve, e.g.
                 "densely dotted" or ["solid", "dashdot", "densely dashed"], by default None
   :type names: list or str, optional

   :returns: List of good linestyles. Either the specified selection or the whole list in
             the predefined order.
   :rtype: list

   :raises ValueError: If `names` is not a str or list.


.. py:data:: global_config
   

   

