:py:mod:`puma.roc`
==================

.. py:module:: puma.roc

.. autoapi-nested-parse::

   ROC curve functions.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   puma.roc.Roc
   puma.roc.RocPlot




.. py:class:: Roc(sig_eff: numpy.ndarray, bkg_rej: numpy.ndarray, n_test: int = None, rej_class: str = None, signal_class: str = None, key: str = None, **kwargs)

   Bases: :py:obj:`puma.plot_base.PlotLineObject`

   ROC class storing info about curve and allows to calculate ratio w.r.t other roc.

   Initialise properties of roc curve object.

   :param sig_eff: array of signal efficiencies
   :type sig_eff: np.array
   :param bkg_rej: array of background rejection
   :type bkg_rej: np.array
   :param n_test: Number of events used to calculate the background efficiencies,
                  by default None
   :type n_test: int
   :param signal_class: Signal class, e.g. for b-tagging "bjets", by default None
   :type signal_class: str
   :param rej_class: Rejection class, e.g. for b-tagging anc charm rejection "cjets",
                     by default None
   :type rej_class: str
   :param key: identifier for roc curve e.g. tagger, by default None
   :type key: str
   :param \*\*kwargs: kwargs passed to `PlotLineObject`
   :type \*\*kwargs: kwargs

   :raises ValueError: if `sig_eff` and `bkg_rej` have a different shape

   .. py:property:: fct_inter

      Interpolate the rejection function for better ratio calculation plotting etc.

      :returns: interpolation function
      :rtype: pchip

   .. py:property:: non_zero_mask

      Masking points where rejection is 0 and no signal efficiency change present

      :returns: masked indices
      :rtype: numpy.array

   .. py:property:: non_zero

      Abstraction of `non_zero_mask`

      :returns: * *numpy.array* -- masked signal efficiency
                * *numpy.array* -- masked background rejection

   .. py:method:: binomial_error(norm: bool = False, n_test: int = None) -> numpy.ndarray

      Calculate binomial error of roc curve.

      :param norm: if True calulate relative error, by default False
      :type norm: bool
      :param n_test: Number of events used to calculate the background efficiencies,
                     by default None
      :type n_test: int

      :returns: binomial error
      :rtype: numpy.array

      :raises ValueError: if no `n_test` was provided


   .. py:method:: divide(roc_comp, inverse: bool = False)

      Calculate ratio between the roc curve and another roc.

      :param roc_comp: second roc curve to calculate ratio with
      :type roc_comp: roc class
      :param inverse: if False the ratio is calculated `this_roc / roc_comp`,
                      if True the inverse is calculated
      :type inverse: bool

      :returns: * *np.array* -- signal efficiency used for the ratio calculation which is the overlapping
                  interval of the two roc curves
                * *np.array* -- ratio
                * *np.array or None* -- ratio_err if `n_test` was provided to class



.. py:class:: RocPlot(**kwargs)

   Bases: :py:obj:`puma.plot_base.PlotBase`

   Roc plot class

   roc plot properties

   :param \*\*kwargs: kwargs from `plot_base`
   :type \*\*kwargs: kwargs

   .. py:method:: add_roc(roc_curve: object, key: str = None, reference: bool = False)

      Adding roc object to figure.

      :param roc_curve: roc curve
      :type roc_curve: roc class
      :param key: unique identifier for roc, by default None
      :type key: str, optional
      :param reference: if roc is used as reference for ratio calculation, by default False
      :type reference: bool, optional

      :raises KeyError: if unique identifier key is used twice


   .. py:method:: set_roc_reference(key: str, rej_class: str)

      Setting the reference roc curves used in the ratios

      :param key: unique identifier of roc object
      :type key: str
      :param rej_class: rejection class encoded in roc curve
      :type rej_class: str

      :raises ValueError: if more rejection classes are set than actual ratio panels available.


   .. py:method:: set_leg_rej_labels(rej_class: str, label: str)

      Set legend label for rejection class

      :param rej_class: rejection class
      :type rej_class: str
      :param label: label added in legend
      :type label: str


   .. py:method:: set_ratio_class(ratio_panel: int, rej_class: str, label: str)

      Associate the rejection class to a ratio panel

      :param ratio_panel: ratio panel either 1 or 2
      :type ratio_panel: int
      :param rej_class: rejeciton class associated to that panel
      :type rej_class: str
      :param label: y-axis label of the ratio panel
      :type label: str

      :raises ValueError: if requested ratio panels and given ratio_panel do not match.


   .. py:method:: add_ratios()

      Calculating ratios.

      :raises ValueError: if number of reference rocs and ratio panels don't match
      :raises ValueError: if no ratio classes are set


   .. py:method:: get_xlim_auto()

      Returns min and max efficiency values

      :returns: min and max efficiency values
      :rtype: float


   .. py:method:: plot_ratios(axis: matplotlib.pyplot.axis, rej_class: str)

      Plotting ratio curves

      :param axis: matplotlib axis object
      :type axis: plt.axis
      :param rej_class: rejection class
      :type rej_class: str


   .. py:method:: make_split_legend(handles)

      Draw legend for the case of 2 ratios, splitting up legend into models and
      rejection class.

      :param handles: list of Line2D objects to extract info for legend
      :type handles: list

      :raises ValueError: if not 2 ratios requested


   .. py:method:: draw(labelpad: int = None)

      Draw plotting

      :param labelpad: Spacing in points from the axes bounding box including
                       ticks and tick labels, by default None
      :type labelpad: int, optional


   .. py:method:: plot_roc(**kwargs) -> matplotlib.lines.Line2D

      Plotting roc curves

      :param \*\*kwargs: kwargs passed to plt.axis.plot
      :type \*\*kwargs: kwargs

      :returns: matplotlib Line2D object
      :rtype: Line2D



